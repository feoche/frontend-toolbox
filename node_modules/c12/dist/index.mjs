import { existsSync, promises } from 'fs';
import { resolve, extname, dirname } from 'pathe';
import * as dotenv from 'dotenv';
import os from 'os';
import createJiti from 'jiti';
import * as rc9 from 'rc9';
import defu from 'defu';

async function setupDotenv(options) {
  const targetEnv = options.env ?? process.env;
  const env = await loadDotenv({
    cwd: options.cwd,
    fileName: options.fileName ?? ".env",
    env: targetEnv,
    interpolate: options.interpolate ?? true
  });
  for (const key in env) {
    if (!key.startsWith("_") && targetEnv[key] === void 0) {
      targetEnv[key] = env[key];
    }
  }
  return env;
}
async function loadDotenv(opts) {
  const env = /* @__PURE__ */ Object.create(null);
  const dotenvFile = resolve(opts.cwd, opts.fileName);
  if (existsSync(dotenvFile)) {
    const parsed = dotenv.parse(await promises.readFile(dotenvFile, "utf-8"));
    Object.assign(env, parsed);
  }
  if (!opts.env._applied) {
    Object.assign(env, opts.env);
    env._applied = true;
  }
  if (opts.interpolate) {
    interpolate(env);
  }
  return env;
}
function interpolate(target, source = {}, parse = (v) => v) {
  function getValue(key) {
    return source[key] !== void 0 ? source[key] : target[key];
  }
  function interpolate2(value, parents = []) {
    if (typeof value !== "string") {
      return value;
    }
    const matches = value.match(/(.?\${?(?:[a-zA-Z0-9_:]+)?}?)/g) || [];
    return parse(matches.reduce((newValue, match) => {
      const parts = /(.?)\${?([a-zA-Z0-9_:]+)?}?/g.exec(match);
      const prefix = parts[1];
      let value2, replacePart;
      if (prefix === "\\") {
        replacePart = parts[0];
        value2 = replacePart.replace("\\$", "$");
      } else {
        const key = parts[2];
        replacePart = parts[0].substring(prefix.length);
        if (parents.includes(key)) {
          console.warn(`Please avoid recursive environment variables ( loop: ${parents.join(" > ")} > ${key} )`);
          return "";
        }
        value2 = getValue(key);
        value2 = interpolate2(value2, [...parents, key]);
      }
      return value2 !== void 0 ? newValue.replace(replacePart, value2) : newValue;
    }, value));
  }
  for (const key in target) {
    target[key] = interpolate2(getValue(key));
  }
}

async function loadConfig(opts) {
  opts.cwd = resolve(process.cwd(), opts.cwd || ".");
  opts.name = opts.name || "config";
  opts.configFile = opts.configFile ?? (opts.name !== "config" ? `${opts.name}.config` : "config");
  opts.rcFile = opts.rcFile ?? `.${opts.name}rc`;
  const r = {
    config: {},
    cwd: opts.cwd,
    configFile: resolve(opts.cwd, opts.configFile),
    layers: []
  };
  if (opts.dotenv) {
    await setupDotenv({
      cwd: opts.cwd,
      ...opts.dotenv === true ? {} : opts.dotenv
    });
  }
  const { config, configFile } = await loadConfigFile(opts.cwd, opts.configFile);
  if (configFile) {
    r.configFile = configFile;
  }
  const configRC = {};
  if (opts.rcFile) {
    if (opts.globalRc) {
      Object.assign(configRC, rc9.readUser({ name: opts.rcFile, dir: opts.cwd }));
    }
    Object.assign(configRC, rc9.read({ name: opts.rcFile, dir: opts.cwd }));
  }
  r.config = defu(opts.overrides, config, configRC, opts.defaults);
  await extendConfig(r.config, opts.configFile, opts.cwd);
  r.layers = r.config._layers;
  delete r.config._layers;
  r.config = defu(r.config, ...r.layers.map((e) => e.config));
  return r;
}
const GIT_PREFIXES = ["github:", "gitlab:", "bitbucket:", "https://"];
async function extendConfig(config, configFile, cwd) {
  config._layers = config._layers || [];
  const extendSources = (Array.isArray(config.extends) ? config.extends : [config.extends]).filter(Boolean);
  delete config.extends;
  for (let extendSource of extendSources) {
    if (GIT_PREFIXES.some((prefix) => extendSource.startsWith(prefix))) {
      const url = new URL(extendSource);
      const subPath = url.pathname.split("/").slice(2).join("/");
      const gitRepo = url.protocol + url.pathname.split("/").slice(0, 2).join("/");
      const tmpdir = resolve(os.tmpdir(), "c12/", gitRepo.replace(/[#:@/\\]/g, "_"));
      await promises.rm(tmpdir, { recursive: true }).catch(() => {
      });
      const gittar = await import('gittar').then((r) => r.default || r);
      const tarFile = await gittar.fetch(gitRepo);
      await gittar.extract(tarFile, tmpdir);
      extendSource = resolve(tmpdir, subPath);
    }
    const isDir = !extname(extendSource);
    const _cwd = resolve(cwd, isDir ? extendSource : dirname(extendSource));
    const _config = await loadConfigFile(_cwd, isDir ? configFile : extendSource);
    if (!_config.config) {
      continue;
    }
    await extendConfig(_config.config, configFile, _cwd);
    config._layers.push({
      config: _config.config,
      cwd: _cwd,
      configFile: _config.configFile
    });
    if (_config.config._layers) {
      config._layers.push(..._config.config._layers);
      delete _config.config._layers;
    }
  }
}
const jiti = createJiti(null, { cache: false, interopDefault: true });
async function loadConfigFile(cwd, configFile) {
  const res = {
    configFile: null,
    config: null
  };
  if (!configFile) {
    return res;
  }
  try {
    res.configFile = jiti.resolve(resolve(cwd, configFile), { paths: [cwd] });
    res.config = jiti(res.configFile);
    if (typeof res.config === "function") {
      res.config = await res.config();
    }
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") {
      throw err;
    }
  }
  return res;
}

export { loadConfig, loadDotenv, setupDotenv };
